// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"github.com/pivotal-cf/service-backup/azure"
	"github.com/pivotal-cf/service-backup/config"
	"github.com/pivotal-cf/service-backup/gcs"
	"github.com/pivotal-cf/service-backup/s3"
	"github.com/pivotal-cf/service-backup/scp"
	"github.com/pivotal-cf/service-backup/upload"
)

type FakeUploaderFactory struct {
	S3Stub        func(destination config.Destination, caCertPath string) *s3.S3CliClient
	s3Mutex       sync.RWMutex
	s3ArgsForCall []struct {
		destination config.Destination
		caCertPath  string
	}
	s3Returns struct {
		result1 *s3.S3CliClient
	}
	s3ReturnsOnCall map[int]struct {
		result1 *s3.S3CliClient
	}
	SCPStub        func(destination config.Destination) *scp.SCPClient
	sCPMutex       sync.RWMutex
	sCPArgsForCall []struct {
		destination config.Destination
	}
	sCPReturns struct {
		result1 *scp.SCPClient
	}
	sCPReturnsOnCall map[int]struct {
		result1 *scp.SCPClient
	}
	AzureStub        func(destination config.Destination) *azure.AzureClient
	azureMutex       sync.RWMutex
	azureArgsForCall []struct {
		destination config.Destination
	}
	azureReturns struct {
		result1 *azure.AzureClient
	}
	azureReturnsOnCall map[int]struct {
		result1 *azure.AzureClient
	}
	GCSStub        func(destination config.Destination) *gcs.StorageClient
	gCSMutex       sync.RWMutex
	gCSArgsForCall []struct {
		destination config.Destination
	}
	gCSReturns struct {
		result1 *gcs.StorageClient
	}
	gCSReturnsOnCall map[int]struct {
		result1 *gcs.StorageClient
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeUploaderFactory) S3(destination config.Destination, caCertPath string) *s3.S3CliClient {
	fake.s3Mutex.Lock()
	ret, specificReturn := fake.s3ReturnsOnCall[len(fake.s3ArgsForCall)]
	fake.s3ArgsForCall = append(fake.s3ArgsForCall, struct {
		destination config.Destination
		caCertPath  string
	}{destination, caCertPath})
	fake.recordInvocation("S3", []interface{}{destination, caCertPath})
	fake.s3Mutex.Unlock()
	if fake.S3Stub != nil {
		return fake.S3Stub(destination, caCertPath)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.s3Returns.result1
}

func (fake *FakeUploaderFactory) S3CallCount() int {
	fake.s3Mutex.RLock()
	defer fake.s3Mutex.RUnlock()
	return len(fake.s3ArgsForCall)
}

func (fake *FakeUploaderFactory) S3ArgsForCall(i int) (config.Destination, string) {
	fake.s3Mutex.RLock()
	defer fake.s3Mutex.RUnlock()
	return fake.s3ArgsForCall[i].destination, fake.s3ArgsForCall[i].caCertPath
}

func (fake *FakeUploaderFactory) S3Returns(result1 *s3.S3CliClient) {
	fake.S3Stub = nil
	fake.s3Returns = struct {
		result1 *s3.S3CliClient
	}{result1}
}

func (fake *FakeUploaderFactory) S3ReturnsOnCall(i int, result1 *s3.S3CliClient) {
	fake.S3Stub = nil
	if fake.s3ReturnsOnCall == nil {
		fake.s3ReturnsOnCall = make(map[int]struct {
			result1 *s3.S3CliClient
		})
	}
	fake.s3ReturnsOnCall[i] = struct {
		result1 *s3.S3CliClient
	}{result1}
}

func (fake *FakeUploaderFactory) SCP(destination config.Destination) *scp.SCPClient {
	fake.sCPMutex.Lock()
	ret, specificReturn := fake.sCPReturnsOnCall[len(fake.sCPArgsForCall)]
	fake.sCPArgsForCall = append(fake.sCPArgsForCall, struct {
		destination config.Destination
	}{destination})
	fake.recordInvocation("SCP", []interface{}{destination})
	fake.sCPMutex.Unlock()
	if fake.SCPStub != nil {
		return fake.SCPStub(destination)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.sCPReturns.result1
}

func (fake *FakeUploaderFactory) SCPCallCount() int {
	fake.sCPMutex.RLock()
	defer fake.sCPMutex.RUnlock()
	return len(fake.sCPArgsForCall)
}

func (fake *FakeUploaderFactory) SCPArgsForCall(i int) config.Destination {
	fake.sCPMutex.RLock()
	defer fake.sCPMutex.RUnlock()
	return fake.sCPArgsForCall[i].destination
}

func (fake *FakeUploaderFactory) SCPReturns(result1 *scp.SCPClient) {
	fake.SCPStub = nil
	fake.sCPReturns = struct {
		result1 *scp.SCPClient
	}{result1}
}

func (fake *FakeUploaderFactory) SCPReturnsOnCall(i int, result1 *scp.SCPClient) {
	fake.SCPStub = nil
	if fake.sCPReturnsOnCall == nil {
		fake.sCPReturnsOnCall = make(map[int]struct {
			result1 *scp.SCPClient
		})
	}
	fake.sCPReturnsOnCall[i] = struct {
		result1 *scp.SCPClient
	}{result1}
}

func (fake *FakeUploaderFactory) Azure(destination config.Destination) *azure.AzureClient {
	fake.azureMutex.Lock()
	ret, specificReturn := fake.azureReturnsOnCall[len(fake.azureArgsForCall)]
	fake.azureArgsForCall = append(fake.azureArgsForCall, struct {
		destination config.Destination
	}{destination})
	fake.recordInvocation("Azure", []interface{}{destination})
	fake.azureMutex.Unlock()
	if fake.AzureStub != nil {
		return fake.AzureStub(destination)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.azureReturns.result1
}

func (fake *FakeUploaderFactory) AzureCallCount() int {
	fake.azureMutex.RLock()
	defer fake.azureMutex.RUnlock()
	return len(fake.azureArgsForCall)
}

func (fake *FakeUploaderFactory) AzureArgsForCall(i int) config.Destination {
	fake.azureMutex.RLock()
	defer fake.azureMutex.RUnlock()
	return fake.azureArgsForCall[i].destination
}

func (fake *FakeUploaderFactory) AzureReturns(result1 *azure.AzureClient) {
	fake.AzureStub = nil
	fake.azureReturns = struct {
		result1 *azure.AzureClient
	}{result1}
}

func (fake *FakeUploaderFactory) AzureReturnsOnCall(i int, result1 *azure.AzureClient) {
	fake.AzureStub = nil
	if fake.azureReturnsOnCall == nil {
		fake.azureReturnsOnCall = make(map[int]struct {
			result1 *azure.AzureClient
		})
	}
	fake.azureReturnsOnCall[i] = struct {
		result1 *azure.AzureClient
	}{result1}
}

func (fake *FakeUploaderFactory) GCS(destination config.Destination) *gcs.StorageClient {
	fake.gCSMutex.Lock()
	ret, specificReturn := fake.gCSReturnsOnCall[len(fake.gCSArgsForCall)]
	fake.gCSArgsForCall = append(fake.gCSArgsForCall, struct {
		destination config.Destination
	}{destination})
	fake.recordInvocation("GCS", []interface{}{destination})
	fake.gCSMutex.Unlock()
	if fake.GCSStub != nil {
		return fake.GCSStub(destination)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.gCSReturns.result1
}

func (fake *FakeUploaderFactory) GCSCallCount() int {
	fake.gCSMutex.RLock()
	defer fake.gCSMutex.RUnlock()
	return len(fake.gCSArgsForCall)
}

func (fake *FakeUploaderFactory) GCSArgsForCall(i int) config.Destination {
	fake.gCSMutex.RLock()
	defer fake.gCSMutex.RUnlock()
	return fake.gCSArgsForCall[i].destination
}

func (fake *FakeUploaderFactory) GCSReturns(result1 *gcs.StorageClient) {
	fake.GCSStub = nil
	fake.gCSReturns = struct {
		result1 *gcs.StorageClient
	}{result1}
}

func (fake *FakeUploaderFactory) GCSReturnsOnCall(i int, result1 *gcs.StorageClient) {
	fake.GCSStub = nil
	if fake.gCSReturnsOnCall == nil {
		fake.gCSReturnsOnCall = make(map[int]struct {
			result1 *gcs.StorageClient
		})
	}
	fake.gCSReturnsOnCall[i] = struct {
		result1 *gcs.StorageClient
	}{result1}
}

func (fake *FakeUploaderFactory) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.s3Mutex.RLock()
	defer fake.s3Mutex.RUnlock()
	fake.sCPMutex.RLock()
	defer fake.sCPMutex.RUnlock()
	fake.azureMutex.RLock()
	defer fake.azureMutex.RUnlock()
	fake.gCSMutex.RLock()
	defer fake.gCSMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeUploaderFactory) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ upload.UploaderFactory = new(FakeUploaderFactory)
